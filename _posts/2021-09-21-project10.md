---
title: "프로젝트 지식(10) - Django Channels"
excerpt: ""

categories:
  - Project
tags:
  - Project101
toc: true
toc_label: "목차"
published: false
---

# 쪽지, 알림 기능 구현

프로젝트의 막바지에 다다랐다. 이제 마지막 우리 프로젝트에서 가장 중요한 기능 구현만이 남았다고 할 수 있는데, 해당 기능을 원활하게 진행하려면 쪽지 기능과 그 쪽지를 받았다는 알림 기능이 필요했다. 알림 같은 경우는 쪽지 뿐만이 아니라 본인의 게시글에 댓글이 달렸을 때, 좋아요를 받았을 때에(이건 아직 미정이다.) 해당 동작에 대한 알림을 주어야 하기 때문에 우리 프로젝트에서 굉장히 중요하고 필요한 기능이다. 

이러한 기능을 구현하기 위해서 어떠한 방법을 사용하면 좋을 지 구글링하던 도중 Django Channels라는 아주 좋은 라이브러리를 알게 되었다. 이번 시간에는 Django Channels(이하 채널스)에 대해 알아보고자 한다.

# 웹 소켓

채널스에 대해 알아보기 전, 이 라이브러리를 구현하기 위해 사용된 핵심 기능을 살펴보고 가야한다. 가장 토대가 되는 것은 웹소켓이다. <a href="https://kgw7401.github.io/project/project8/">이전</a> 포스트에서 아주 간략하게 다룬 적이 있는데, 조금 더 살펴볼 필요가 있을 것 같아 다시 한 번 다뤄보려 한다.

우리가 주로 사용하는 HTTP는 사용자가 서버에 요청을 보내야만 서버가 응답을 할 수 있는 구조였다. 사용자는 일방적으로 데이터를 전송할 수 있지만, 서버는 불가능하다는 것이다. 

보통의 기능을 구현하는데 이것은 별 문제가 될 것이 없지만, 실시간 요청을 받아야 하는 알림과 같은 기능은 문제가 된다.

예를 들어, 누군가가 내 게시물에 댓글을 달았다거나 채팅을 보냈을 때 HTTP 같은 경우는 내가 해당 알림에 대한 요청을 보내야만 응답을 받을 수 있을 것이다. 서버로부터 새로운 정보를 받기 위해서는 반드시! 새로운 URL을 요청해야 한다는 것이다.

하지만 우리가 인스타그램이나 기타 커뮤니티에서 봤던 방식은 우리가 요청하지 않아도 서버에서 응답을 보내준다. 클라이언트의 요청 없이도 서버가 응답을 보내준다는 것이 핵심인데, 이를 실행가능하게 해주는 기술이 바로 웹소켓인 것이다. 

# 비동기 프로그래밍

채널스를 원활하게 사용하기 위해서는 웹소켓 뿐 아니라 비동기 프로그래밍에 대해서도 잘 알아놓아야 한다. 비동기를 간단하게 설명하면 작업을 다른 쓰레드에 맡기고 기다리지 않는 것이다. 그 말인 즉슨, 메인쓰레드가 다른 일 처리를 시작할 수 있다는 것이다. 반면 동기는 기다리는 것이다. 만약 다른 쓰레드로 작업을 보낸다고 하더라도 그 작업이 끝나는 동안에는 메인 쓰레드가 블락될 것이다.

<img src="">

원래 파이썬에서는 비동기 프로그래밍 지원이 안되었었는데, 3.6버전이 되면서 이러한 비동기 프로그래밍을 지원하였다. 기존의 함수 `def` 앞에 `async` 키워드를 붙이면 비동기 처리되며 파이썬에서  비동기 함수를 코루틴(coroutine)이라고 부르며 일반 동기 함수처럼 호출하면 코루틴 객체가 리턴된다. 이러한 비동기 함수를 실행하기 위해서는 다른 비동기 함수 내에서 `await` 키워드를 붙여서 사용해야 한다. 만약 동기 함수 내에서 호출하려면 `asyncio.run(async_func())`으로 사용해야 한다.

파이썬의 비동기 프로그래밍 동작 원리를 좀 더 알려면 <a href="https://it-eldorado.tistory.com/159">여기</a> 링크에 아주 자세히 설명되어 있다. 

# Django channels 튜토리얼

이제 본격적으로 채널스에 대해 알아보도록 하자. 인터넷 자료를 서치해보니 대부분이 공식문서의 튜토리얼을 기반으로 한 자료여서 그냥 공식문서를 보는 것이 나을 것 같아 공식 튜토리얼로 사용법과 기능을 익히고, 이해가 잘 안되는 부분이나 궁금한 부분은 공식 문서 혹은 구글링을 통해 보충하였다.

튜토리얼이 잘 나와있어서 딱히 다시 한 번 정리할 필요는 없을 것 같아 중요내용이나 잘 이해 안 갔던 부분만 추려서 포스팅하였다. 공식문서와 구글링으로 어느정도 기반을 다지면 이번 프로젝트에서 구현할 기능을 위해 학습한 내용을 기반으로 전체적인 틀을 조금 잡아보려 한다. 

## Django Channels 기본 작동 원리

<img src="">

<img src="">

채널스를 도입하면 내부적으로는 기존의 장고가 작동하던 방식과 달라지지만 사용자는 동일하게 사용할 수 있다. 위의 그림과 같이 조금 더 복잡한 작동원리가 추가되긴 하였지만 외부적으로는 동일한 메커니즘을 가진다. 

### wsgi vs asgi

우리가 기본적으로 사용하고 있던 wsgi는 웹서버와 장고를 연결해주는 인터페이스이다. runserver를 통해 로컬에서 이를 실행하기도 하고 실제 배포할 때는 gunicorn이나 uwsgi와 같은 툴을 사용하기도 한다. 

하지만 이러한 기존의 wsgi는 앞서 살펴보았던 비동기 프로그래밍을 효과적으로 다루지 못한다는 단점이 있었고 이러한 문제를 해결하기 위해 나온 것이 바로 asgi이다. 채널스는 웹소켓을 이용하기 때문에 wsgi가 아닌 asgi를 사용해야 한다. 참고로 asgi와 wsgi를 같이 사용하는 것이 아니라 asgi를 wsgi 대신 사용하는 것이다. asgi 안에서도 HTTP 프로토콜을 모두 처리할 수 있다. 

※ 프로덕션

대형 사이트에서는 일반 HTTP 요청은 Gunicorn+Django와 같은 프로덕션의 WSGI 서버로 전달하고 웹소켓 요청은 Daphne+Channels와 같은 프로덕션의 ASGI 서버로 전달해 처리하는 것이 좋다. 작은 규모의 사이트는 그냥 Daphne 서버가 혼자 모든 요청-HTTP와 웹소켓 둘 다-을 처리하도록 할 수도 있다.

### 기존의 장고와 대응

채널스는 기존의 장고와 대응되는 것들이 굉장히 많기 때문에 장고를 어느정도 아는 사람들은 이해가 아주 쉽다.

<img src="">

### consumer 들여다보기

consumer는 크게 다음고 같은 과정으로 동작한다. 연결 승낙하고(accept)하고, 클라이언트로부터 메시지를 받고(receive) 다시 돌려준다(send). 

이러한 과정을 여러 컨슈머들끼리나 장고의 다른 부분들과도 소통할 수 있게 해주는 것이 채널 레이어이다. 채널 레이어는 채널과 그룹으로 구성되어 있고, 채널은 메시지가 전달되는 우편함, 그룹은 관련있는 채널들의 모임이다. 다른 사람과 소통을 하고 싶다면 채널을 그룹에 등록하고 메시지를 전파해야 한다. 

# Channels 심화

앞선 튜토리얼을 통해 기본적인 채팅앱은 구현이 가능했다. 브라우저를 닫았다가 다시 열면 채팅 기록이 전혀 저장되지 않는 것을 볼 수 있다. 채팅이 저장이 안된다면 말도 안되기 때문에 데이터베이스를 이용해서 채팅을 저장해야 한다. 

# Reference

- <a href="https://channels.readthedocs.io/en/stable/">Django Channels 공식 문서</a>
- <a href="https://medium.com/@whj2013123218/%EC%9E%A5%EA%B3%A0-django-channels%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EC%97%AC-%EA%B8%B0%EB%B3%B8-%EC%95%8C%EB%9E%8C-%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-%EC%85%8B%ED%8C%85%ED%8E%B8-9a344b905429">장고(Django) Channels를 활용하여 기본 알람 기능 구현하기</a>
- <a href="https://www.youtube.com/watch?v=xrKKRRC518Y&list=PLLRM7ROnmA9EnQmnfTgUzCfzbbnc-oEbZ&index=2">Django Channels Tutorial</a>